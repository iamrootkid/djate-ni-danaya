// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || "https://vfrutnkohrviouttwsnu.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZmcnV0bmtvaHJ2aW91dHR3c251Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI2MTQ5NTgsImV4cCI6MjA1ODE5MDk1OH0.ohyxAjqesiCyofKgoNcuRMpMdeB8W1dd2paWEbJjVl4";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Queue for rate-limiting requests
const requestQueue: Array<() => Promise<void>> = [];
let isProcessingQueue = false;
let retryCount = 0;
const MAX_RETRIES = 3;

// Process requests from the queue with retry logic
async function processQueue() {
  if (isProcessingQueue || requestQueue.length === 0) return;
  
  isProcessingQueue = true;
  
  try {
    while (requestQueue.length > 0) {
      const request = requestQueue.shift();
      if (request) {
        try {
          await request();
          retryCount = 0; // Reset retry count on success
        } catch (error) {
          if (retryCount < MAX_RETRIES) {
            retryCount++;
            requestQueue.unshift(request); // Put the request back in the queue
            await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 1000)); // Exponential backoff
          } else {
            console.error('Max retries reached for request:', error);
            retryCount = 0;
          }
        }
        await new Promise(resolve => setTimeout(resolve, 300));
      }
    }
  } finally {
    isProcessingQueue = false;
  }
}

// Configure the client with proper settings to handle token refresh and session persistence
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true,
    flowType: 'implicit',
  },
  realtime: {
    params: {
      eventsPerSecond: 1
    }
  },
  db: {
    schema: 'public',
  },
  // Improved request handling with retry logic
  requestTransformer: (req, nextHandler) => {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error('Request timeout'));
      }, 10000);

      const attemptRequest = async (attempt = 1) => {
        try {
          const response = await nextHandler(req);
          clearTimeout(timeoutId);
          resolve(response);
        } catch (error) {
          if (attempt < MAX_RETRIES) {
            await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
            return attemptRequest(attempt + 1);
          }
          clearTimeout(timeoutId);
          reject(error);
        }
      };

      attemptRequest();
    });
  }
});

// Helper function to safely handle Supabase queries with proper typing
export function asStringParam(param: string | number | boolean): string {
  return param as unknown as string;
}

/**
 * Fix for JWT token expiration issues
 * This ensures we don't have tokens with excessively long expiration times
 */
export async function fixJwtTokenIfNeeded() {
  try {
    const { data: session } = await supabase.auth.getSession();
    if (!session.session) return;
    
    const token = session.session.access_token;
    if (!token) return;
    
    // Parse JWT to check expiration
    const payload = JSON.parse(atob(token.split('.')[1]));
    const expTime = payload.exp * 1000; // Convert to milliseconds
    const now = Date.now();
    
    // If token expires more than 1 hour from now, refresh it
    if (expTime - now > 3600000 || expTime < now) {
      console.log("Refreshing access token to fix expiration time");
      await supabase.auth.refreshSession();
    }
  } catch (e) {
    console.error("Error checking JWT token:", e);
  }
}

// Rate limiting cache with improved cleanup
const rateLimitCache = new Map<string, { timestamp: number, count: number }>();

// Cleanup old rate limit entries every 5 minutes
setInterval(() => {
  const now = Date.now();
  for (const [key, value] of rateLimitCache.entries()) {
    if (now - value.timestamp > 300000) { // 5 minutes
      rateLimitCache.delete(key);
    }
  }
}, 300000);

/**
 * Helper to check if a request should be rate limited
 * @param key Unique identifier for the request type
 * @param maxRequests Maximum requests allowed per window
 * @param windowMs Time window in milliseconds
 * @returns Boolean indicating if the request should be throttled
 */
export function shouldRateLimit(key: string, maxRequests = 5, windowMs = 1000): boolean {
  const now = Date.now();
  const cacheKey = `rate_limit_${key}`;
  
  // Get or initialize cache entry
  const entry = rateLimitCache.get(cacheKey) || { timestamp: now, count: 0 };
  
  // Reset if window has passed
  if (now - entry.timestamp > windowMs) {
    entry.timestamp = now;
    entry.count = 1;
    rateLimitCache.set(cacheKey, entry);
    return false;
  }
  
  // Check if limit is exceeded
  if (entry.count >= maxRequests) {
    return true;
  }
  
  // Increment counter
  entry.count++;
  rateLimitCache.set(cacheKey, entry);
  return false;
}
